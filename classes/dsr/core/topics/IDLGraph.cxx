// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DSRGraph.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "IDLGraph.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace IDL {
    Val::Val() {
        m__d = 0;
        // m_str com.eprosima.idl.parser.typecode.StringTypeCode@4cf4d528
        m_str = "";
        // m_dec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@77846d2c
        m_dec = 0;
        // m_fl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@548ad73b
        m_fl = 0.0;
        // m_float_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@4c762604

        // m_bl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2641e737
        m_bl = false;
        // m_byte_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@727803de

        m_uint = 0;
    }

    Val::~Val() {
    }

    Val::Val(const Val &x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = x.m_str;
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = x.m_float_vec;
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = x.m_byte_vec;
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            default:
                break;
        }
    }

    Val::Val(Val &&x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = std::move(x.m_str);
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = std::move(x.m_float_vec);
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = std::move(x.m_byte_vec);
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            default:
                break;
        }
    }

    Val &Val::operator=(const Val &x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = x.m_str;
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = x.m_float_vec;
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = x.m_byte_vec;
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            default:
                break;
        }

        return *this;
    }

    Val &Val::operator=(Val &&x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = std::move(x.m_str);
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = std::move(x.m_float_vec);
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = std::move(x.m_byte_vec);
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            default:
                break;
        }

        return *this;
    }

    void Val::_d(int32_t __d) {
        bool b = false;

        switch (m__d) {
            case 0:
                switch (__d) {
                    case 0:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 1:
                switch (__d) {
                    case 1:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 2:
                switch (__d) {
                    case 2:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 3:
                switch (__d) {
                    case 3:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 4:
                switch (__d) {
                    case 4:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 5:
                switch (__d) {
                    case 5:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 6:
                switch (__d) {
                    case 6:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
        }

        if (!b) {
            throw BadParamException("Discriminator doesn't correspond with the selected union member");
        }

        m__d = __d;
    }

    int32_t Val::_d() const {
        return m__d;
    }

    int32_t &Val::_d() {
        return m__d;
    }

    void Val::str(const std::string &_str) {
        m_str = _str;
        m__d = 0;
    }

    void Val::str(std::string &&_str) {
        m_str = std::move(_str);
        m__d = 0;
    }

    const std::string &Val::str() const {
        bool b = false;

        switch (m__d) {
            case 0:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_str;
    }

    std::string &Val::str() {
        bool b = false;

        switch (m__d) {
            case 0:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_str;
    }

    void Val::dec(int32_t _dec) {
        m_dec = _dec;
        m__d = 1;
    }

    int32_t Val::dec() const {
        bool b = false;

        switch (m__d) {
            case 1:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dec;
    }

    int32_t &Val::dec() {
        bool b = false;

        switch (m__d) {
            case 1:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dec;
    }

    void Val::uint(uint32_t _uint) {
        m_uint = _uint;
        m__d = 6;
    }

    uint32_t Val::uint() const {
        bool b = false;

        switch (m__d) {
            case 6:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint;
    }

    uint32_t &Val::uint() {
        bool b = false;

        switch (m__d) {
            case 6:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint;
    }


    void Val::fl(float _fl) {
        m_fl = _fl;
        m__d = 2;
    }

    float Val::fl() const {
        bool b = false;

        switch (m__d) {
            case 2:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_fl;
    }

    float &Val::fl() {
        bool b = false;

        switch (m__d) {
            case 2:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_fl;
    }

    void Val::float_vec(const std::vector<float> &_float_vec) {
        m_float_vec = _float_vec;
        m__d = 3;
    }

    void Val::float_vec(std::vector<float> &&_float_vec) {
        m_float_vec = std::move(_float_vec);
        m__d = 3;
    }

    const std::vector<float> &Val::float_vec() const {
        bool b = false;

        switch (m__d) {
            case 3:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_float_vec;
    }

    std::vector<float> &Val::float_vec() {
        bool b = false;

        switch (m__d) {
            case 3:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_float_vec;
    }

    void Val::bl(bool _bl) {
        m_bl = _bl;
        m__d = 4;
    }

    bool Val::bl() const {
        bool b = false;

        switch (m__d) {
            case 4:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_bl;
    }

    bool &Val::bl() {
        bool b = false;

        switch (m__d) {
            case 4:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_bl;
    }

    void Val::byte_vec(const std::vector<uint8_t> &_byte_vec) {
        m_byte_vec = _byte_vec;
        m__d = 5;
    }

    void Val::byte_vec(std::vector<uint8_t> &&_byte_vec) {
        m_byte_vec = std::move(_byte_vec);
        m__d = 5;
    }

    const std::vector<uint8_t> &Val::byte_vec() const {
        bool b = false;

        switch (m__d) {
            case 5:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_byte_vec;
    }

    std::vector<uint8_t> &Val::byte_vec() {
        bool b = false;

        switch (m__d) {
            case 5:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_byte_vec;
    }

    size_t Val::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;
        size_t reset_alignment = 0;
        size_t union_max_size_serialized = 0;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        return union_max_size_serialized - initial_alignment;
    }

// TODO(Ricardo) Review
    size_t Val::getCdrSerializedSize(const Val &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        switch (data.m__d) {
            case 0:
                current_alignment +=
                        4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;
                break;
            case 1:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            case 2:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            case 3:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (data.float_vec().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


                break;
            case 4:
                current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

                break;
            case 5:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (data.byte_vec().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

            case 6:

                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            default:
                break;
        }

        return current_alignment - initial_alignment;
    }

    void Val::serialize(eprosima::fastcdr::Cdr &scdr) const {
        scdr << m__d;

        switch (m__d) {
            case 0:
                scdr << m_str;
                break;
            case 1:
                scdr << m_dec;
                break;
            case 2:
                scdr << m_fl;
                break;
            case 3:
                scdr << m_float_vec;
                break;
            case 4:
                scdr << m_bl;
                break;
            case 5:
                scdr << m_byte_vec;
                break;
            case 6:
                scdr << m_uint;
                break;
            default:
                break;
        }
    }

    void Val::deserialize(eprosima::fastcdr::Cdr &dcdr) {
        dcdr >> m__d;

        switch (m__d) {
            case 0:
                dcdr >> m_str;
                break;
            case 1:
                dcdr >> m_dec;
                break;
            case 2:
                dcdr >> m_fl;
                break;
            case 3:
                dcdr >> m_float_vec;
                break;
            case 4:
                dcdr >> m_bl;
                break;
            case 5:
                dcdr >> m_byte_vec;
                break;
            case 6:
                dcdr >> m_uint;
                break;
            default:
                break;
        }
    }


    Attrib::Attrib() {
        // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7ff2a664
        m_type = 0;
        // m_value com.eprosima.idl.parser.typecode.UnionTypeCode@525b461a

        // m_timestamp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@58c1c010
        m_timestamp = 0;
        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@b7f23d9
        m_agent_id = 0;

    }

    Attrib::~Attrib() {


    }

    Attrib::Attrib(const Attrib &x) {
        m_type = x.m_type;
        m_value = x.m_value;
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;
    }

    Attrib::Attrib(Attrib &&x) {
        m_type = x.m_type;
        m_value = std::move(x.m_value);
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;
    }

    Attrib &Attrib::operator=(const Attrib &x) {

        m_type = x.m_type;
        m_value = x.m_value;
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    Attrib &Attrib::operator=(Attrib &&x) {

        m_type = x.m_type;
        m_value = std::move(x.m_value);
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t Attrib::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += Val::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t Attrib::getCdrSerializedSize(const Attrib &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += Val::getCdrSerializedSize(data.value(), current_alignment);
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void Attrib::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_type;
        scdr << m_value;
        scdr << m_timestamp;
        scdr << m_agent_id;
    }

    void Attrib::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_type;
        dcdr >> m_value;
        dcdr >> m_timestamp;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
    void Attrib::type(uint32_t _type) {
        m_type = _type;
    }

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
    uint32_t Attrib::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    uint32_t &Attrib::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
    void Attrib::value(const Val &_value) {
        m_value = _value;
    }

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
    void Attrib::value(Val &&_value) {
        m_value = std::move(_value);
    }

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
    const Val &Attrib::value() const {
        return m_value;
    }

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
    Val &Attrib::value() {
        return m_value;
    }

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
    void Attrib::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
    uint64_t Attrib::timestamp() const {
        return m_timestamp;
    }

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
    uint64_t &Attrib::timestamp() {
        return m_timestamp;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void Attrib::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t Attrib::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &Attrib::agent_id() {
        return m_agent_id;
    }


    size_t Attrib::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool Attrib::isKeyDefined() {
        return false;
    }

    void Attrib::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    PairInt::PairInt() {
        // m_first com.eprosima.idl.parser.typecode.PrimitiveTypeCode@279ad2e3
        m_first = 0;
        // m_second com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4461c7e3
        m_second = 0;

    }

    PairInt::~PairInt() {


    }

    PairInt::PairInt(const PairInt &x) {
        m_first = x.m_first;
        m_second = x.m_second;
    }

    PairInt::PairInt(PairInt &&x) {
        m_first = x.m_first;
        m_second = x.m_second;
    }

    PairInt &PairInt::operator=(const PairInt &x) {

        m_first = x.m_first;
        m_second = x.m_second;

        return *this;
    }

    PairInt &PairInt::operator=(PairInt &&x) {

        m_first = x.m_first;
        m_second = x.m_second;

        return *this;
    }

    size_t PairInt::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t PairInt::getCdrSerializedSize(const PairInt &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void PairInt::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_first;
        scdr << m_second;
    }

    void PairInt::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_first;
        dcdr >> m_second;
    }

/*!
 * @brief This function sets a value in member first
 * @param _first New value for member first
 */
    void PairInt::first(uint32_t _first) {
        m_first = _first;
    }

/*!
 * @brief This function returns the value of member first
 * @return Value of member first
 */
    uint32_t PairInt::first() const {
        return m_first;
    }

/*!
 * @brief This function returns a reference to member first
 * @return Reference to member first
 */
    uint32_t &PairInt::first() {
        return m_first;
    }

/*!
 * @brief This function sets a value in member second
 * @param _second New value for member second
 */
    void PairInt::second(int32_t _second) {
        m_second = _second;
    }

/*!
 * @brief This function returns the value of member second
 * @return Value of member second
 */
    int32_t PairInt::second() const {
        return m_second;
    }

/*!
 * @brief This function returns a reference to member second
 * @return Reference to member second
 */
    int32_t &PairInt::second() {
        return m_second;
    }


    size_t PairInt::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool PairInt::isKeyDefined() {
        return false;
    }

    void PairInt::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotContext::DotContext() {
        // m_cc com.eprosima.idl.parser.typecode.MapTypeCode@255b53dc

        // m_dc com.eprosima.idl.parser.typecode.SequenceTypeCode@1dd92fe2


    }

    DotContext::~DotContext() {


    }

    DotContext::DotContext(const DotContext &x) {
        m_cc = x.m_cc;
        m_dc = x.m_dc;
    }

    DotContext::DotContext(DotContext &&x) {
        m_cc = std::move(x.m_cc);
        m_dc = std::move(x.m_dc);
    }

    DotContext &DotContext::operator=(const DotContext &x) {

        m_cc = x.m_cc;
        m_dc = x.m_dc;

        return *this;
    }

    DotContext &DotContext::operator=(DotContext &&x) {

        m_cc = std::move(x.m_cc);
        m_dc = std::move(x.m_dc);

        return *this;
    }

    size_t DotContext::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < 100; ++a) {
            current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    size_t DotContext::getCdrSerializedSize(const DotContext &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.cc()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < data.dc().size(); ++a) {
            current_alignment += PairInt::getCdrSerializedSize(data.dc().at(a), current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    void DotContext::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_cc;
        scdr << m_dc;
    }

    void DotContext::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_cc;
        dcdr >> m_dc;
    }

/*!
 * @brief This function copies the value in member cc
 * @param _cc New value to be copied in member cc
 */
    void DotContext::cc(const std::map<uint32_t, int32_t> &_cc) {
        m_cc = _cc;
    }

/*!
 * @brief This function moves the value in member cc
 * @param _cc New value to be moved in member cc
 */
    void DotContext::cc(std::map<uint32_t, int32_t> &&_cc) {
        m_cc = std::move(_cc);
    }

/*!
 * @brief This function returns a constant reference to member cc
 * @return Constant reference to member cc
 */
    const std::map<uint32_t, int32_t> &DotContext::cc() const {
        return m_cc;
    }

/*!
 * @brief This function returns a reference to member cc
 * @return Reference to member cc
 */
    std::map<uint32_t, int32_t> &DotContext::cc() {
        return m_cc;
    }

/*!
 * @brief This function copies the value in member dc
 * @param _dc New value to be copied in member dc
 */
    void DotContext::dc(const std::vector<PairInt> &_dc) {
        m_dc = _dc;
    }

/*!
 * @brief This function moves the value in member dc
 * @param _dc New value to be moved in member dc
 */
    void DotContext::dc(std::vector<PairInt> &&_dc) {
        m_dc = std::move(_dc);
    }

/*!
 * @brief This function returns a constant reference to member dc
 * @return Constant reference to member dc
 */
    const std::vector<PairInt> &DotContext::dc() const {
        return m_dc;
    }

/*!
 * @brief This function returns a reference to member dc
 * @return Reference to member dc
 */
    std::vector<PairInt> &DotContext::dc() {
        return m_dc;
    }

    size_t DotContext::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotContext::isKeyDefined() {
        return false;
    }

    void DotContext::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotKernelAttr::DotKernelAttr() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@1b68b9a4

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4f9a3314


    }

    DotKernelAttr::~DotKernelAttr() {


    }

    DotKernelAttr::DotKernelAttr(const DotKernelAttr &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernelAttr::DotKernelAttr(DotKernelAttr &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernelAttr &DotKernelAttr::operator=(const DotKernelAttr &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernelAttr &DotKernelAttr::operator=(DotKernelAttr &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernelAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);

            current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernelAttr::getCdrSerializedSize(const DotKernelAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernelAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernelAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernelAttr::ds(const std::map<PairInt, Attrib> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernelAttr::ds(std::map<PairInt, Attrib> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, Attrib> &DotKernelAttr::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, Attrib> &DotKernelAttr::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernelAttr::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernelAttr::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernelAttr::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernelAttr::cbase() {
        return m_cbase;
    }

    size_t DotKernelAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernelAttr::isKeyDefined() {
        return false;
    }

    void DotKernelAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregEdgeAttr::MvregEdgeAttr() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@57175e74
        m_id = 0;
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7bb58ca3
        m_from = 0;
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@c540f5a
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@770c2e6b
        m_type = "";
        // m_attr_name com.eprosima.idl.parser.typecode.StringTypeCode@1a052a00
        m_attr_name = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4d826d77

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@61009542
        m_agent_id = 0;

    }

    MvregEdgeAttr::~MvregEdgeAttr() {


    }

    MvregEdgeAttr::MvregEdgeAttr(const MvregEdgeAttr &x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
    }

    MvregEdgeAttr::MvregEdgeAttr(MvregEdgeAttr &&x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
    }

    MvregEdgeAttr &MvregEdgeAttr::operator=(const MvregEdgeAttr &x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    MvregEdgeAttr &MvregEdgeAttr::operator=(MvregEdgeAttr &&x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t MvregEdgeAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelAttr::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t MvregEdgeAttr::getCdrSerializedSize(const MvregEdgeAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.attr_name().size() + 1;

        current_alignment += DotKernelAttr::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void MvregEdgeAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_from;
        scdr << m_to;
        scdr << m_type;
        scdr << m_attr_name;
        scdr << m_dk;
        scdr << m_agent_id;
    }

    void MvregEdgeAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_from;
        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_attr_name;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregEdgeAttr::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t MvregEdgeAttr::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &MvregEdgeAttr::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void MvregEdgeAttr::from(uint32_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint32_t MvregEdgeAttr::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint32_t &MvregEdgeAttr::from() {
        return m_from;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void MvregEdgeAttr::to(uint32_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint32_t MvregEdgeAttr::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint32_t &MvregEdgeAttr::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void MvregEdgeAttr::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void MvregEdgeAttr::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &MvregEdgeAttr::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &MvregEdgeAttr::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
    void MvregEdgeAttr::attr_name(const std::string &_attr_name) {
        m_attr_name = _attr_name;
    }

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
    void MvregEdgeAttr::attr_name(std::string &&_attr_name) {
        m_attr_name = std::move(_attr_name);
    }

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
    const std::string &MvregEdgeAttr::attr_name() const {
        return m_attr_name;
    }

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
    std::string &MvregEdgeAttr::attr_name() {
        return m_attr_name;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregEdgeAttr::dk(const DotKernelAttr &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregEdgeAttr::dk(DotKernelAttr &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelAttr &MvregEdgeAttr::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelAttr &MvregEdgeAttr::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregEdgeAttr::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregEdgeAttr::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregEdgeAttr::agent_id() {
        return m_agent_id;
    }


    size_t MvregEdgeAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregEdgeAttr::isKeyDefined() {
        return false;
    }

    void MvregEdgeAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    IDLEdge::IDLEdge() {
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@44a664f2
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@6328d34a
        m_type = "";
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@145eaa29
        m_from = 0;
        // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@15bb6bea

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@8b96fde
        m_agent_id = 0;

    }

    IDLEdge::~IDLEdge() {


    }

    IDLEdge::IDLEdge(const IDLEdge &x) {
        m_to = x.m_to;
        m_type = x.m_type;
        m_from = x.m_from;
        m_attrs = x.m_attrs;
        m_agent_id = x.m_agent_id;
    }

    IDLEdge::IDLEdge(IDLEdge &&x) {
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_from = x.m_from;
        m_attrs = std::move(x.m_attrs);
        m_agent_id = x.m_agent_id;
    }

    IDLEdge &IDLEdge::operator=(const IDLEdge &x) {

        m_to = x.m_to;
        m_type = x.m_type;
        m_from = x.m_from;
        m_attrs = x.m_attrs;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    IDLEdge &IDLEdge::operator=(IDLEdge &&x) {

        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_from = x.m_from;
        m_attrs = std::move(x.m_attrs);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t IDLEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


            current_alignment += MvregEdgeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t IDLEdge::getCdrSerializedSize(const IDLEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.attrs()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
            current_alignment += MvregEdgeAttr::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void IDLEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_to;
        scdr << m_type;
        scdr << m_from;
        scdr << m_attrs;
        scdr << m_agent_id;
    }

    void IDLEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_from;
        dcdr >> m_attrs;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void IDLEdge::to(uint32_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint32_t IDLEdge::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint32_t &IDLEdge::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void IDLEdge::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void IDLEdge::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &IDLEdge::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &IDLEdge::type() {
        return m_type;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void IDLEdge::from(uint32_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint32_t IDLEdge::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint32_t &IDLEdge::from() {
        return m_from;
    }

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
    void IDLEdge::attrs(const std::map<std::string, MvregEdgeAttr> &_attrs) {
        m_attrs = _attrs;
    }

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
    void IDLEdge::attrs(std::map<std::string, MvregEdgeAttr> &&_attrs) {
        m_attrs = std::move(_attrs);
    }

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
    const std::map<std::string, MvregEdgeAttr> &IDLEdge::attrs() const {
        return m_attrs;
    }

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
    std::map<std::string, MvregEdgeAttr> &IDLEdge::attrs() {
        return m_attrs;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void IDLEdge::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t IDLEdge::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &IDLEdge::agent_id() {
        return m_agent_id;
    }


    size_t IDLEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool IDLEdge::isKeyDefined() {
        return false;
    }

    void IDLEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    EdgeKey::EdgeKey() {
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2ea6137
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@57d5872c
        m_type = "";

    }

    EdgeKey::~EdgeKey() {


    }

    EdgeKey::EdgeKey(const EdgeKey &x) {
        m_to = x.m_to;
        m_type = x.m_type;
    }

    EdgeKey::EdgeKey(EdgeKey &&x) {
        m_to = x.m_to;
        m_type = std::move(x.m_type);
    }

    EdgeKey &EdgeKey::operator=(const EdgeKey &x) {

        m_to = x.m_to;
        m_type = x.m_type;

        return *this;
    }

    EdgeKey &EdgeKey::operator=(EdgeKey &&x) {

        m_to = x.m_to;
        m_type = std::move(x.m_type);

        return *this;
    }

    size_t EdgeKey::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        return current_alignment - initial_alignment;
    }

    size_t EdgeKey::getCdrSerializedSize(const EdgeKey &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;


        return current_alignment - initial_alignment;
    }

    void EdgeKey::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_to;
        scdr << m_type;
    }

    void EdgeKey::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_to;
        dcdr >> m_type;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void EdgeKey::to(uint32_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint32_t EdgeKey::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint32_t &EdgeKey::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void EdgeKey::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void EdgeKey::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &EdgeKey::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &EdgeKey::type() {
        return m_type;
    }

    size_t EdgeKey::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool EdgeKey::isKeyDefined() {
        return false;
    }

    void EdgeKey::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregNodeAttr::MvregNodeAttr() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@55040f2f
        m_id = 0;
        // m_node com.eprosima.idl.parser.typecode.PrimitiveTypeCode@64c87930
        m_node = 0;
        // m_attr_name com.eprosima.idl.parser.typecode.StringTypeCode@400cff1a
        m_attr_name = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4d826d77

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@75f9eccc
        m_agent_id = 0;

    }

    MvregNodeAttr::~MvregNodeAttr() {


    }

    MvregNodeAttr::MvregNodeAttr(const MvregNodeAttr &x) {
        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
    }

    MvregNodeAttr::MvregNodeAttr(MvregNodeAttr &&x) {
        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
    }

    MvregNodeAttr &MvregNodeAttr::operator=(const MvregNodeAttr &x) {

        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    MvregNodeAttr &MvregNodeAttr::operator=(MvregNodeAttr &&x) {

        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t MvregNodeAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelAttr::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t MvregNodeAttr::getCdrSerializedSize(const MvregNodeAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.attr_name().size() + 1;

        current_alignment += DotKernelAttr::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void MvregNodeAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_node;
        scdr << m_attr_name;
        scdr << m_dk;
        scdr << m_agent_id;
    }

    void MvregNodeAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_node;
        dcdr >> m_attr_name;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregNodeAttr::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t MvregNodeAttr::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &MvregNodeAttr::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member node
 * @param _node New value for member node
 */
    void MvregNodeAttr::node(uint32_t _node) {
        m_node = _node;
    }

/*!
 * @brief This function returns the value of member node
 * @return Value of member node
 */
    uint32_t MvregNodeAttr::node() const {
        return m_node;
    }

/*!
 * @brief This function returns a reference to member node
 * @return Reference to member node
 */
    uint32_t &MvregNodeAttr::node() {
        return m_node;
    }

/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
    void MvregNodeAttr::attr_name(const std::string &_attr_name) {
        m_attr_name = _attr_name;
    }

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
    void MvregNodeAttr::attr_name(std::string &&_attr_name) {
        m_attr_name = std::move(_attr_name);
    }

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
    const std::string &MvregNodeAttr::attr_name() const {
        return m_attr_name;
    }

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
    std::string &MvregNodeAttr::attr_name() {
        return m_attr_name;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregNodeAttr::dk(const DotKernelAttr &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregNodeAttr::dk(DotKernelAttr &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelAttr &MvregNodeAttr::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelAttr &MvregNodeAttr::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregNodeAttr::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregNodeAttr::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregNodeAttr::agent_id() {
        return m_agent_id;
    }


    size_t MvregNodeAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregNodeAttr::isKeyDefined() {
        return false;
    }

    void MvregNodeAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotKernelEdge::DotKernelEdge() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@52aa2946

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4f9a3314


    }

    DotKernelEdge::~DotKernelEdge() {


    }

    DotKernelEdge::DotKernelEdge(const DotKernelEdge &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernelEdge::DotKernelEdge(DotKernelEdge &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernelEdge &DotKernelEdge::operator=(const DotKernelEdge &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernelEdge &DotKernelEdge::operator=(DotKernelEdge &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernelEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);

            current_alignment += IDLEdge::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernelEdge::getCdrSerializedSize(const DotKernelEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += IDLEdge::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernelEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernelEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernelEdge::ds(const std::map<PairInt, IDLEdge> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernelEdge::ds(std::map<PairInt, IDLEdge> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, IDLEdge> &DotKernelEdge::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, IDLEdge> &DotKernelEdge::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernelEdge::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernelEdge::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernelEdge::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernelEdge::cbase() {
        return m_cbase;
    }

    size_t DotKernelEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernelEdge::isKeyDefined() {
        return false;
    }

    void DotKernelEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregEdge::MvregEdge() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4de5031f
        m_id = 0;
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@67e2d983
        m_from = 0;
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5d47c63f
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@5ea434c8
        m_type = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@3bbc39f8

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4ae3c1cd
        m_agent_id = 0;

    }

    MvregEdge::~MvregEdge() {


    }

    MvregEdge::MvregEdge(const MvregEdge &x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
    }

    MvregEdge::MvregEdge(MvregEdge &&x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
    }

    MvregEdge &MvregEdge::operator=(const MvregEdge &x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    MvregEdge &MvregEdge::operator=(MvregEdge &&x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t MvregEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelEdge::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t MvregEdge::getCdrSerializedSize(const MvregEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += DotKernelEdge::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void MvregEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_from;
        scdr << m_to;
        scdr << m_type;
        scdr << m_dk;
        scdr << m_agent_id;
    }

    void MvregEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_from;
        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregEdge::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t MvregEdge::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &MvregEdge::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void MvregEdge::from(uint32_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint32_t MvregEdge::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint32_t &MvregEdge::from() {
        return m_from;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void MvregEdge::to(uint32_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint32_t MvregEdge::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint32_t &MvregEdge::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void MvregEdge::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void MvregEdge::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &MvregEdge::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &MvregEdge::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregEdge::dk(const DotKernelEdge &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregEdge::dk(DotKernelEdge &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelEdge &MvregEdge::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelEdge &MvregEdge::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregEdge::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregEdge::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregEdge::agent_id() {
        return m_agent_id;
    }


    size_t MvregEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregEdge::isKeyDefined() {
        return false;
    }

    void MvregEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    IDLNode::IDLNode() {
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@ca263c2
        m_type = "";
        // m_name com.eprosima.idl.parser.typecode.StringTypeCode@589b3632
        m_name = "";
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@45f45fa1
        m_id = 0;
        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4c6e276e
        m_agent_id = 0;
        // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@534df152

        // m_fano com.eprosima.idl.parser.typecode.MapTypeCode@52e677af


    }

    IDLNode::~IDLNode() {


    }

    IDLNode::IDLNode(const IDLNode &x) {
        m_type = x.m_type;
        m_name = x.m_name;
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = x.m_attrs;
        m_fano = x.m_fano;
    }

    IDLNode::IDLNode(IDLNode &&x) {
        m_type = std::move(x.m_type);
        m_name = std::move(x.m_name);
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = std::move(x.m_attrs);
        m_fano = std::move(x.m_fano);
    }

    IDLNode &IDLNode::operator=(const IDLNode &x) {

        m_type = x.m_type;
        m_name = x.m_name;
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = x.m_attrs;
        m_fano = x.m_fano;

        return *this;
    }

    IDLNode &IDLNode::operator=(IDLNode &&x) {

        m_type = std::move(x.m_type);
        m_name = std::move(x.m_name);
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = std::move(x.m_attrs);
        m_fano = std::move(x.m_fano);

        return *this;
    }

    size_t IDLNode::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


            current_alignment += MvregNodeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += EdgeKey::getMaxCdrSerializedSize(current_alignment);

            current_alignment += MvregEdge::getMaxCdrSerializedSize(current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    size_t IDLNode::getCdrSerializedSize(const IDLNode &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.attrs()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
            current_alignment += MvregNodeAttr::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.fano()) {
            (void) a;
            current_alignment += EdgeKey::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += MvregEdge::getCdrSerializedSize((a.second), current_alignment);

        }


        return current_alignment - initial_alignment;
    }

    void IDLNode::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_type;
        scdr << m_name;
        scdr << m_id;
        scdr << m_agent_id;
        scdr << m_attrs;
        scdr << m_fano;
    }

    void IDLNode::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_type;
        dcdr >> m_name;
        dcdr >> m_id;
        dcdr >> m_agent_id;
        dcdr >> m_attrs;
        dcdr >> m_fano;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void IDLNode::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void IDLNode::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &IDLNode::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &IDLNode::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
    void IDLNode::name(const std::string &_name) {
        m_name = _name;
    }

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
    void IDLNode::name(std::string &&_name) {
        m_name = std::move(_name);
    }

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
    const std::string &IDLNode::name() const {
        return m_name;
    }

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
    std::string &IDLNode::name() {
        return m_name;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void IDLNode::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t IDLNode::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &IDLNode::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void IDLNode::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t IDLNode::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &IDLNode::agent_id() {
        return m_agent_id;
    }

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
    void IDLNode::attrs(const std::map<std::string, MvregNodeAttr> &_attrs) {
        m_attrs = _attrs;
    }

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
    void IDLNode::attrs(std::map<std::string, MvregNodeAttr> &&_attrs) {
        m_attrs = std::move(_attrs);
    }

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
    const std::map<std::string, MvregNodeAttr> &IDLNode::attrs() const {
        return m_attrs;
    }

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
    std::map<std::string, MvregNodeAttr> &IDLNode::attrs() {
        return m_attrs;
    }

/*!
 * @brief This function copies the value in member fano
 * @param _fano New value to be copied in member fano
 */
    void IDLNode::fano(const std::map<EdgeKey, MvregEdge> &_fano) {
        m_fano = _fano;
    }

/*!
 * @brief This function moves the value in member fano
 * @param _fano New value to be moved in member fano
 */
    void IDLNode::fano(std::map<EdgeKey, MvregEdge> &&_fano) {
        m_fano = std::move(_fano);
    }

/*!
 * @brief This function returns a constant reference to member fano
 * @return Constant reference to member fano
 */
    const std::map<EdgeKey, MvregEdge> &IDLNode::fano() const {
        return m_fano;
    }

/*!
 * @brief This function returns a reference to member fano
 * @return Reference to member fano
 */
    std::map<EdgeKey, MvregEdge> &IDLNode::fano() {
        return m_fano;
    }

    size_t IDLNode::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool IDLNode::isKeyDefined() {
        return false;
    }

    void IDLNode::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    GraphRequest::GraphRequest() {
        // m_from com.eprosima.idl.parser.typecode.StringTypeCode@341b80b2
        m_from = "";

    }

    GraphRequest::~GraphRequest() {
    }

    GraphRequest::GraphRequest(const GraphRequest &x) {
        m_from = x.m_from;
    }

    GraphRequest::GraphRequest(GraphRequest &&x) {
        m_from = std::move(x.m_from);
    }

    GraphRequest &GraphRequest::operator=(const GraphRequest &x) {

        m_from = x.m_from;

        return *this;
    }

    GraphRequest &GraphRequest::operator=(GraphRequest &&x) {

        m_from = std::move(x.m_from);

        return *this;
    }

    size_t GraphRequest::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        return current_alignment - initial_alignment;
    }

    size_t GraphRequest::getCdrSerializedSize(const GraphRequest &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.from().size() + 1;

        return current_alignment - initial_alignment;
    }

    void GraphRequest::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_from;
    }

    void GraphRequest::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_from;
    }

/*!
 * @brief This function copies the value in member from
 * @param _from New value to be copied in member from
 */
    void GraphRequest::from(const std::string &_from) {
        m_from = _from;
    }

/*!
 * @brief This function moves the value in member from
 * @param _from New value to be moved in member from
 */
    void GraphRequest::from(std::string &&_from) {
        m_from = std::move(_from);
    }

/*!
 * @brief This function returns a constant reference to member from
 * @return Constant reference to member from
 */
    const std::string &GraphRequest::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    std::string &GraphRequest::from() {
        return m_from;
    }

    size_t GraphRequest::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool GraphRequest::isKeyDefined() {
        return false;
    }

    void GraphRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;

    }

    DotKernel::DotKernel() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@55a1c291

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4f9a3314


    }

    DotKernel::~DotKernel() {


    }

    DotKernel::DotKernel(const DotKernel &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernel::DotKernel(DotKernel &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernel &DotKernel::operator=(const DotKernel &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernel &DotKernel::operator=(DotKernel &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernel::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);

            current_alignment += IDLNode::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernel::getCdrSerializedSize(const DotKernel &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += IDLNode::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernel::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernel::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernel::ds(const std::map<PairInt, IDLNode> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernel::ds(std::map<PairInt, IDLNode> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, IDLNode> &DotKernel::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, IDLNode> &DotKernel::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernel::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernel::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernel::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernel::cbase() {
        return m_cbase;
    }

    size_t DotKernel::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernel::isKeyDefined() {
        return false;
    }

    void DotKernel::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    Mvreg::Mvreg() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2145433b
        m_id = 0;
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@2890c451

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@40e6dfe1
        m_agent_id = 0;

    }

    Mvreg::~Mvreg() {


    }

    Mvreg::Mvreg(const Mvreg &x) {
        m_id = x.m_id;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
    }

    Mvreg::Mvreg(Mvreg &&x) {
        m_id = x.m_id;
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
    }

    Mvreg &Mvreg::operator=(const Mvreg &x) {

        m_id = x.m_id;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    Mvreg &Mvreg::operator=(Mvreg &&x) {

        m_id = x.m_id;
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t Mvreg::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += DotKernel::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t Mvreg::getCdrSerializedSize(const Mvreg &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += DotKernel::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void Mvreg::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_dk;
        scdr << m_agent_id;
    }

    void Mvreg::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void Mvreg::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t Mvreg::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &Mvreg::id() {
        return m_id;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void Mvreg::dk(const DotKernel &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void Mvreg::dk(DotKernel &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernel &Mvreg::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernel &Mvreg::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void Mvreg::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t Mvreg::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &Mvreg::agent_id() {
        return m_agent_id;
    }


    size_t Mvreg::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool Mvreg::isKeyDefined() {
        return false;
    }

    void Mvreg::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    OrMap::OrMap() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1b083826
        m_id = 0;
        // m_m com.eprosima.idl.parser.typecode.MapTypeCode@105fece7

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@4f9a3314


    }

    OrMap::~OrMap() {


    }

    OrMap::OrMap(const OrMap &x) {
        m_id = x.m_id;
        m_m = x.m_m;
        m_cbase = x.m_cbase;
    }

    OrMap::OrMap(OrMap &&x) {
        m_id = x.m_id;
        m_m = std::move(x.m_m);
        m_cbase = std::move(x.m_cbase);
    }

    OrMap &OrMap::operator=(const OrMap &x) {

        m_id = x.m_id;
        m_m = x.m_m;
        m_cbase = x.m_cbase;

        return *this;
    }

    OrMap &OrMap::operator=(OrMap &&x) {

        m_id = x.m_id;
        m_m = std::move(x.m_m);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t OrMap::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            current_alignment += Mvreg::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t OrMap::getCdrSerializedSize(const OrMap &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.m()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


            current_alignment += Mvreg::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void OrMap::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_m;
        scdr << m_cbase;
    }

    void OrMap::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_m;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void OrMap::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t OrMap::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &OrMap::id() {
        return m_id;
    }

/*!
 * @brief This function copies the value in member m
 * @param _m New value to be copied in member m
 */
    void OrMap::m(const std::map<uint32_t, Mvreg> &_m) {
        m_m = _m;
    }

/*!
 * @brief This function moves the value in member m
 * @param _m New value to be moved in member m
 */
    void OrMap::m(std::map<uint32_t, Mvreg> &&_m) {
        m_m = std::move(_m);
    }

/*!
 * @brief This function returns a constant reference to member m
 * @return Constant reference to member m
 */
    const std::map<uint32_t, Mvreg> &OrMap::m() const {
        return m_m;
    }

/*!
 * @brief This function returns a reference to member m
 * @return Reference to member m
 */
    std::map<uint32_t, Mvreg> &OrMap::m() {
        return m_m;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void OrMap::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void OrMap::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &OrMap::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &OrMap::cbase() {
        return m_cbase;
    }

    size_t OrMap::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool OrMap::isKeyDefined() {
        return false;
    }

    void OrMap::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

}
