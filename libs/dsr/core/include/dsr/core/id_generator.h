//
// Created by juancarlos on 19/1/21.
//

/*
 * This is based in Sony's sonyflake, which is inspired on Twitter's snowflake.
 * The id is composed by a timestamp of 40 bits, a counter of 12 bits and
 * an agent identifier os 12 bits. Unlike the projects on which it is based on,
 * this can generate 64-bits ids instead of 63-bits ones generated by the previous,
 * as it is not intended to be used on architectures that do not support
 * unsigned 64-bits numbers.
 *
 * Each timestamp represent a 10 milliseconds periods since 2021-01-01 00:00:00 GTM.
 * The counter is used to differentiate between ids generated in the same timestamp.
 * The id allows to generate unique ids in a distributed environment as long as the id
 * is unique.
 * */

#ifndef ID_GENERATOR_H
#define ID_GENERATOR_H

#include <mutex>

//Bits for each field.
static constexpr auto time_size = 40;    // lower bits of the timestamps.
static constexpr auto counter_size = 12; //
static constexpr auto agent_id_size = 12;

//Time unit to get different timestamp every 10 ms with a nonosecond timestamp.
static constexpr auto time_unit = 1e7;


class id_generator
{
    using mtx_type = std::mutex;

    uint64_t start_time;    //Timestamp of start.
    uint64_t elapsed_time;  //Difference between last point and start_time, used to create the time segment in the id.
    uint16_t agent_id;      //identifier of the agent. This value must be unique for each generator. The "agent_id" of the agent should be used here.
    uint16_t counter;       //Counter to generate ids in an equal timestamp.
    mtx_type mtx;           //Lock for thread safe generation.
    std::chrono::system_clock::time_point last_point; //We use this to check that time_point doesn't go backwards. TODO: we should use a monotonic clock.

    [[nodiscard]] static inline bool check_agent_id(uint16_t agent_id) {
        return agent_id < (1<<agent_id_size);
    }

    inline std::chrono::system_clock::time_point get_time_point();
public:

    explicit id_generator(uint16_t agent_id_)
    {
        if (!check_agent_id(agent_id_))
        {
            throw std::logic_error("agent_id must be between 0 and 4095");
        }

        start_time = 1609459200000000000; // epoch of 2021-01-01 00:00:00 GMT in nanoseconds
        elapsed_time = 0;
        agent_id = agent_id_;
        counter  = 0;
        last_point = std::chrono::system_clock::time_point { std::chrono::system_clock::duration {0}};
    }

    [[nodiscard]] uint64_t generate();
    [[nodiscard]] static std::tuple<uint64_t, uint16_t, uint16_t> parse(uint64_t id);
    [[nodiscard]] static std::string hex_string(uint64_t id);

};


#endif //ID_GENERATOR_H
