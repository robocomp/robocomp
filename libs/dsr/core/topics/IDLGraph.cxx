// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file IDLGraph.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include <dsr/core/topics/IDLGraph.h>
#include <fastcdr/Cdr.h>
#include <cassert>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>
namespace IDL {

    Val::Val() {
        m__d = 0;
        // m_str com.eprosima.idl.parser.typecode.StringTypeCode@2f0a87b3
        m_str = "";
        // m_dec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@319b92f3
        m_dec = 0;
        // m_fl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@fcd6521
        m_fl = 0.0;
        // m_float_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@27d415d9

        // m_bl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5c18298f
        m_bl = false;
        // m_byte_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@31f924f5

        // m_uint com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5579bb86
        m_uint = 0;
        // m_u64 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@376b4233
        m_u64 = 0;

        m_dob = 0.0;
    }

    Val::~Val() = default;

    Val::Val(const Val &x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = x.m_str;
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = x.m_float_vec;
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = x.m_byte_vec;
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            case 7:
                m_u64 = x.m_u64;
                break;
            case 8:
                m_dob = x.m_dob;
                break;
            case 9:
                m_uint64_vec = x.m_uint64_vec;
                break;
            case 10:
                m_vec_float2 = x.m_vec_float2;
                break;
            case 11:
                m_vec_float3 = x.m_vec_float3;
                break;
            case 12:
                m_vec_float4 = x.m_vec_float4;
                break;
            case 13:
                m_vec_float6 = x.m_vec_float6;
                break;
            default:
                break;
        }
    }

    Val::Val(Val &&x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = std::move(x.m_str);
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = std::move(x.m_float_vec);
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = std::move(x.m_byte_vec);
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            case 7:
                m_u64 = x.m_u64;
                break;
            case 8:
                m_dob = x.m_dob;
                break;
            case 9:
                m_uint64_vec = std::move(x.m_uint64_vec);
                break;
            case 10:
                m_vec_float2 = std::move(x.m_vec_float2);
                break;
            case 11:
                m_vec_float3 = std::move(x.m_vec_float3);
                break;
            case 12:
                m_vec_float4 = std::move(x.m_vec_float4);
                break;
            case 13:
                m_vec_float6 = std::move(x.m_vec_float6);
                break;
            default:
                break;
        }
    }

    Val &Val::operator=(const Val &x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = x.m_str;
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = x.m_float_vec;
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = x.m_byte_vec;
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            case 7:
                m_u64 = x.m_u64;
                break;
            case 8:
                m_dob = x.m_dob;
                break;
            case 9:
                m_uint64_vec = x.m_uint64_vec;
                break;
            case 10:
                m_vec_float2 = x.m_vec_float2;
                break;
            case 11:
                m_vec_float3 = x.m_vec_float3;
                break;
            case 12:
                m_vec_float4 = x.m_vec_float4;
                break;
            case 13:
                m_vec_float6 = x.m_vec_float6;
                break;
            default:
                break;
        }

        return *this;
    }

    Val &Val::operator=(Val &&x) {
        m__d = x.m__d;

        switch (m__d) {
            case 0:
                m_str = std::move(x.m_str);
                break;
            case 1:
                m_dec = x.m_dec;
                break;
            case 2:
                m_fl = x.m_fl;
                break;
            case 3:
                m_float_vec = std::move(x.m_float_vec);
                break;
            case 4:
                m_bl = x.m_bl;
                break;
            case 5:
                m_byte_vec = std::move(x.m_byte_vec);
                break;
            case 6:
                m_uint = x.m_uint;
                break;
            case 7:
                m_u64 = x.m_u64;
                break;
            case 8:
                m_dob = x.m_dob;
                break;
            case 9:
                m_uint64_vec = std::move(x.m_uint64_vec);
                break;
            case 10:
                m_vec_float2 = std::move(x.m_vec_float2);
                break;
            case 11:
                m_vec_float3 = std::move(x.m_vec_float3);
                break;
            case 12:
                m_vec_float4 = std::move(x.m_vec_float4);
                break;
            case 13:
                m_vec_float6 = std::move(x.m_vec_float6);
                break;
            default:
                break;
        }

        return *this;
    }

    void Val::_d(int32_t __d) {
        bool b = false;

        switch (m__d) {
            case 0:
                switch (__d) {
                    case 0:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 1:
                switch (__d) {
                    case 1:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 2:
                switch (__d) {
                    case 2:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 3:
                switch (__d) {
                    case 3:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 4:
                switch (__d) {
                    case 4:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 5:
                switch (__d) {
                    case 5:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 6:
                switch (__d) {
                    case 6:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
            case 7:
                switch (__d) {
                    case 7:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 8:
                switch (__d) {
                    case 8:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 9:
                switch (__d) {
                    case 9:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 10:
                switch (__d) {
                    case 10:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 11:
                switch (__d) {
                    case 11:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 12:
                switch (__d) {
                    case 12:
                        b = true;
                        break;
                    default:
                        break;
                }
            case 13:
                switch (__d) {
                    case 13:
                        b = true;
                        break;
                    default:
                        break;
                }
                break;
        }

        if (!b) {
            throw BadParamException("Discriminator doesn't correspond with the selected union member");
        }

        m__d = __d;
    }

    int32_t Val::_d() const {
        return m__d;
    }

    int32_t &Val::_d() {
        return m__d;
    }

    void Val::str(const std::string &_str) {
        m_str = _str;
        m__d = 0;
    }

    void Val::str(std::string &&_str) {
        m_str = std::move(_str);
        m__d = 0;
    }

    const std::string &Val::str() const {
        bool b = false;

        switch (m__d) {
            case 0:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_str;
    }

    std::string &Val::str() {
        bool b = false;

        switch (m__d) {
            case 0:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_str;
    }

    void Val::dec(int32_t _dec) {
        m_dec = _dec;
        m__d = 1;
    }

    int32_t Val::dec() const {
        bool b = false;

        switch (m__d) {
            case 1:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dec;
    }

    int32_t &Val::dec() {
        bool b = false;

        switch (m__d) {
            case 1:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dec;
    }

    void Val::fl(float _fl) {
        m_fl = _fl;
        m__d = 2;
    }

    float Val::fl() const {
        bool b = false;

        switch (m__d) {
            case 2:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_fl;
    }

    float &Val::fl() {
        bool b = false;

        switch (m__d) {
            case 2:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_fl;
    }

    void Val::float_vec(const std::vector<float> &_float_vec) {
        m_float_vec = _float_vec;
        m__d = 3;
    }

    void Val::float_vec(std::vector<float> &&_float_vec) {
        m_float_vec = std::move(_float_vec);
        m__d = 3;
    }

    const std::vector<float> &Val::float_vec() const {
        bool b = false;

        switch (m__d) {
            case 3:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_float_vec;
    }

    std::vector<float> &Val::float_vec() {
        bool b = false;

        switch (m__d) {
            case 3:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_float_vec;
    }

    void Val::bl(bool _bl) {
        m_bl = _bl;
        m__d = 4;
    }

    bool Val::bl() const {
        bool b = false;

        switch (m__d) {
            case 4:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_bl;
    }

    bool &Val::bl() {
        bool b = false;

        switch (m__d) {
            case 4:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_bl;
    }

    void Val::byte_vec(const std::vector<uint8_t> &_byte_vec) {
        m_byte_vec = _byte_vec;
        m__d = 5;
    }

    void Val::byte_vec(std::vector<uint8_t> &&_byte_vec) {
        m_byte_vec = std::move(_byte_vec);
        m__d = 5;
    }

    const std::vector<uint8_t> &Val::byte_vec() const {
        bool b = false;

        switch (m__d) {
            case 5:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_byte_vec;
    }

    std::vector<uint8_t> &Val::byte_vec() {
        bool b = false;

        switch (m__d) {
            case 5:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_byte_vec;
    }

    void Val::uint(uint32_t _uint) {
        m_uint = _uint;
        m__d = 6;
    }

    uint32_t Val::uint() const {
        bool b = false;

        switch (m__d) {
            case 6:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint;
    }

    uint32_t &Val::uint() {
        bool b = false;

        switch (m__d) {
            case 6:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint;
    }

    void Val::u64(uint64_t _u64) {
        m_u64 = _u64;
        m__d = 7;
    }

    uint64_t Val::u64() const {
        bool b = false;

        switch (m__d) {
            case 7:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_u64;
    }

    uint64_t &Val::u64() {
        bool b = false;

        switch (m__d) {
            case 7:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_u64;
    }


    void Val::dob(double _dob) {
        m_dob = _dob;
        m__d = 8;
    }

    double Val::dob() const {
        bool b = false;

        switch (m__d) {
            case 8:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dob;
    }

    double &Val::dob() {
        bool b = false;

        switch (m__d) {
            case 8:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_dob;
    }

    void Val::uint64_vec(const std::vector<uint64_t> &_uint64_vec) {
        m_uint64_vec = _uint64_vec;
        m__d = 9;
    }

    void Val::uint64_vec(std::vector<uint64_t> &&_uint64_vec) {
        m_uint64_vec = std::move(_uint64_vec);
        m__d = 9;
    }

    const std::vector<uint64_t> &Val::uint64_vec() const {
        bool b = false;

        switch (m__d) {
            case 9:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint64_vec;
    }

    std::vector<uint64_t> &Val::uint64_vec() {
        bool b = false;

        switch (m__d) {
            case 9:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_uint64_vec;
    }


    void Val::vec_float2(const std::array<float, 2> &_vec_float2) {
        m_vec_float2 = _vec_float2;
        m__d = 10;
    }

    void Val::vec_float2(std::array<float, 2> &&_vec_float2) {
        m_vec_float2 = std::move(_vec_float2);
        m__d = 10;
    }

    const std::array<float, 2> &Val::vec_float2() const {
        bool b = false;

        switch (m__d) {
            case 10:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float2;
    }

    std::array<float, 2> &Val::vec_float2() {
        bool b = false;

        switch (m__d) {
            case 10:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float2;
    }


    void Val::vec_float3(const std::array<float, 3> &_vec_float3) {
        m_vec_float3 = _vec_float3;
        m__d = 11;
    }

    void Val::vec_float3(std::array<float, 3> &&_vec_float3) {
        m_vec_float3 = std::move(_vec_float3);
        m__d = 11;
    }

    const std::array<float, 3> &Val::vec_float3() const {
        bool b = false;

        switch (m__d) {
            case 11:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float3;
    }

    std::array<float, 3> &Val::vec_float3() {
        bool b = false;

        switch (m__d) {
            case 11:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float3;
    }

    void Val::vec_float4(const std::array<float, 4> &_vec_float4) {
        m_vec_float4 = _vec_float4;
        m__d = 12;
    }

    void Val::vec_float4(std::array<float, 4> &&_vec_float4) {
        m_vec_float4 = std::move(_vec_float4);
        m__d = 12;
    }

    const std::array<float, 4> &Val::vec_float4() const {
        bool b = false;

        switch (m__d) {
            case 12:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float4;
    }

    std::array<float, 4> &Val::vec_float4() {
        bool b = false;

        switch (m__d) {
            case 12:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float4;
    }

    void Val::vec_float6(const std::array<float, 6> &_vec_float6) {
        m_vec_float6 = _vec_float6;
        m__d = 13;
    }

    void Val::vec_float6(std::array<float, 6> &&_vec_float6) {
        m_vec_float6 = std::move(_vec_float6);
        m__d = 13;
    }

    const std::array<float, 6> &Val::vec_float6() const {
        bool b = false;

        switch (m__d) {
            case 13:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float6;
    }

    std::array<float, 6> &Val::vec_float6() {
        bool b = false;

        switch (m__d) {
            case 13:
                b = true;
                break;
            default:
                break;
        }
        if (!b) {
            throw BadParamException("This member is not been selected");
        }

        return m_vec_float6;
    }

    size_t Val::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;
        size_t reset_alignment = 0;
        size_t union_max_size_serialized = 0;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 8 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 8);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        reset_alignment = current_alignment;

        reset_alignment += 8 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 8);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        reset_alignment = current_alignment;

        reset_alignment += 8 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 8);

        reset_alignment += (100 * 8) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 8);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (2 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (3 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (4 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (6 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if (union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        return union_max_size_serialized - initial_alignment;
    }

// TODO(Ricardo) Review
    size_t Val::getCdrSerializedSize(const Val &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        switch (data.m__d) {
            case 0:
                current_alignment +=
                        4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;
                break;
            case 1:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            case 2:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            case 3:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (data.float_vec().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


                break;
            case 4:
                current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

                break;
            case 5:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (data.byte_vec().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


                break;
            case 6:
                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                break;
            case 7:
                current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

                break;

            case 8:
                current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

                break;

            case 9:

                current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

                current_alignment +=
                        (data.uint64_vec().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
            case 10:

                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (4 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            case 11:


                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (4 * 3) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            case 12:


                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (4 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            case 13:


                current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

                current_alignment +=
                        (4 * 6) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

            default:
                break;
        }

        return current_alignment - initial_alignment;
    }

    void Val::serialize(eprosima::fastcdr::Cdr &scdr) const {
        scdr << m__d;

        switch (m__d) {
            case 0:
                scdr << m_str;
                break;
            case 1:
                scdr << m_dec;
                break;
            case 2:
                scdr << m_fl;
                break;
            case 3:
                scdr << m_float_vec;
                break;
            case 4:
                scdr << m_bl;
                break;
            case 5:
                scdr << m_byte_vec;
                break;
            case 6:
                scdr << m_uint;
                break;
            case 7:
                scdr << m_u64;
                break;
            case 8:
                scdr << m_dob;
                break;
            case 9:
                scdr << m_uint64_vec;
                break;
            case 10:
                scdr << m_vec_float2;
                break;
            case 11:
                scdr << m_vec_float3;
                break;
            case 12:
                scdr << m_vec_float4;
                break;
            case 13:
                scdr << m_vec_float6;
                break;
            default:
                break;
        }
    }

    void Val::deserialize(eprosima::fastcdr::Cdr &dcdr) {
        dcdr >> m__d;

        switch (m__d) {
            case 0:
                dcdr >> m_str;
                break;
            case 1:
                dcdr >> m_dec;
                break;
            case 2:
                dcdr >> m_fl;
                break;
            case 3:
                dcdr >> m_float_vec;
                break;
            case 4:
                dcdr >> m_bl;
                break;
            case 5:
                dcdr >> m_byte_vec;
                break;
            case 6:
                dcdr >> m_uint;
                break;
            case 7:
                dcdr >> m_u64;
                break;
            case 8:
                dcdr >> m_dob;
                break;
            case 9:
                dcdr >> m_uint64_vec;
                break;
            case 10:
                dcdr >> m_vec_float2;
                break;
            case 11:
                dcdr >> m_vec_float3;
                break;
            case 12:
                dcdr >> m_vec_float4;
                break;
            case 13:
                dcdr >> m_vec_float6;
                break;
            default:
                break;
        }
    }


    Attrib::Attrib() {
        // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4d339552
        m_type = 0;
        // m_value com.eprosima.idl.parser.typecode.UnionTypeCode@f0f2775

        // m_timestamp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5a4aa2f2
        m_timestamp = 0;
        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@429bd883
        m_agent_id = 0;

    }

    Attrib::~Attrib() {


    }

    Attrib::Attrib(const Attrib &x) {
        m_type = x.m_type;
        m_value = x.m_value;
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;
    }

    Attrib::Attrib(Attrib &&x) {
        m_type = x.m_type;
        m_value = std::move(x.m_value);
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;
    }

    Attrib &Attrib::operator=(const Attrib &x) {

        m_type = x.m_type;
        m_value = x.m_value;
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    Attrib &Attrib::operator=(Attrib &&x) {

        m_type = x.m_type;
        m_value = std::move(x.m_value);
        m_timestamp = x.m_timestamp;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t Attrib::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += Val::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t Attrib::getCdrSerializedSize(const Attrib &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += Val::getCdrSerializedSize(data.value(), current_alignment);
        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void Attrib::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_type;
        scdr << m_value;
        scdr << m_timestamp;
        scdr << m_agent_id;
    }

    void Attrib::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_type;
        dcdr >> m_value;
        dcdr >> m_timestamp;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
    void Attrib::type(uint32_t _type) {
        m_type = _type;
    }

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
    uint32_t Attrib::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    uint32_t &Attrib::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
    void Attrib::value(const Val &_value) {
        m_value = _value;
    }

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
    void Attrib::value(Val &&_value) {
        m_value = std::move(_value);
    }

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
    const Val &Attrib::value() const {
        return m_value;
    }

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
    Val &Attrib::value() {
        return m_value;
    }

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
    void Attrib::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
    uint64_t Attrib::timestamp() const {
        return m_timestamp;
    }

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
    uint64_t &Attrib::timestamp() {
        return m_timestamp;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void Attrib::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t Attrib::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &Attrib::agent_id() {
        return m_agent_id;
    }


    size_t Attrib::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool Attrib::isKeyDefined() {
        return false;
    }

    void Attrib::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    PairInt::PairInt() {
        // m_first com.eprosima.idl.parser.typecode.PrimitiveTypeCode@731f8236
        m_first = 0;
        // m_second com.eprosima.idl.parser.typecode.PrimitiveTypeCode@255b53dc
        m_second = 0;

    }

    PairInt::~PairInt() {


    }

    PairInt::PairInt(const PairInt &x) {
        m_first = x.m_first;
        m_second = x.m_second;
    }

    PairInt::PairInt(PairInt &&x) {
        m_first = x.m_first;
        m_second = x.m_second;
    }

    PairInt &PairInt::operator=(const PairInt &x) {

        m_first = x.m_first;
        m_second = x.m_second;

        return *this;
    }

    PairInt &PairInt::operator=(PairInt &&x) {

        m_first = x.m_first;
        m_second = x.m_second;

        return *this;
    }

    size_t PairInt::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t PairInt::getCdrSerializedSize(const PairInt &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void PairInt::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_first;
        scdr << m_second;
    }

    void PairInt::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_first;
        dcdr >> m_second;
    }

/*!
 * @brief This function sets a value in member first
 * @param _first New value for member first
 */
    void PairInt::first(uint64_t _first) {
        m_first = _first;
    }

/*!
 * @brief This function returns the value of member first
 * @return Value of member first
 */
    uint64_t PairInt::first() const {
        return m_first;
    }

/*!
 * @brief This function returns a reference to member first
 * @return Reference to member first
 */
    uint64_t &PairInt::first() {
        return m_first;
    }

/*!
 * @brief This function sets a value in member second
 * @param _second New value for member second
 */
    void PairInt::second(int32_t _second) {
        m_second = _second;
    }

/*!
 * @brief This function returns the value of member second
 * @return Value of member second
 */
    int32_t PairInt::second() const {
        return m_second;
    }

/*!
 * @brief This function returns a reference to member second
 * @return Reference to member second
 */
    int32_t &PairInt::second() {
        return m_second;
    }


    size_t PairInt::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool PairInt::isKeyDefined() {
        return false;
    }

    void PairInt::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotContext::DotContext() {
        // m_cc com.eprosima.idl.parser.typecode.MapTypeCode@4f9a3314

        // m_dc com.eprosima.idl.parser.typecode.SequenceTypeCode@3b2c72c2


    }

    DotContext::~DotContext() {


    }

    DotContext::DotContext(const DotContext &x) {
        m_cc = x.m_cc;
        m_dc = x.m_dc;
    }

    DotContext::DotContext(DotContext &&x) {
        m_cc = std::move(x.m_cc);
        m_dc = std::move(x.m_dc);
    }

    DotContext &DotContext::operator=(const DotContext &x) {

        m_cc = x.m_cc;
        m_dc = x.m_dc;

        return *this;
    }

    DotContext &DotContext::operator=(DotContext &&x) {

        m_cc = std::move(x.m_cc);
        m_dc = std::move(x.m_dc);

        return *this;
    }

    size_t DotContext::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < 100; ++a) {
            current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    size_t DotContext::getCdrSerializedSize(const DotContext &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (auto a : data.cc()) {
            (void) a;
            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < data.dc().size(); ++a) {
            current_alignment += PairInt::getCdrSerializedSize(data.dc().at(a), current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    void DotContext::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_cc;
        scdr << m_dc;
    }

    void DotContext::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_cc;
        dcdr >> m_dc;
    }

/*!
 * @brief This function copies the value in member cc
 * @param _cc New value to be copied in member cc
 */
    void DotContext::cc(const std::map<uint64_t, int32_t> &_cc) {
        m_cc = _cc;
    }

/*!
 * @brief This function moves the value in member cc
 * @param _cc New value to be moved in member cc
 */
    void DotContext::cc(std::map<uint64_t, int32_t> &&_cc) {
        m_cc = std::move(_cc);
    }

/*!
 * @brief This function returns a constant reference to member cc
 * @return Constant reference to member cc
 */
    const std::map<uint64_t, int32_t> &DotContext::cc() const {
        return m_cc;
    }

/*!
 * @brief This function returns a reference to member cc
 * @return Reference to member cc
 */
    std::map<uint64_t, int32_t> &DotContext::cc() {
        return m_cc;
    }

/*!
 * @brief This function copies the value in member dc
 * @param _dc New value to be copied in member dc
 */
    void DotContext::dc(const std::vector<PairInt> &_dc) {
        m_dc = _dc;
    }

/*!
 * @brief This function moves the value in member dc
 * @param _dc New value to be moved in member dc
 */
    void DotContext::dc(std::vector<PairInt> &&_dc) {
        m_dc = std::move(_dc);
    }

/*!
 * @brief This function returns a constant reference to member dc
 * @return Constant reference to member dc
 */
    const std::vector<PairInt> &DotContext::dc() const {
        return m_dc;
    }

/*!
 * @brief This function returns a reference to member dc
 * @return Reference to member dc
 */
    std::vector<PairInt> &DotContext::dc() {
        return m_dc;
    }

    size_t DotContext::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotContext::isKeyDefined() {
        return false;
    }

    void DotContext::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotKernelAttr::DotKernelAttr() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@971d0d8

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@51931956


    }

    DotKernelAttr::~DotKernelAttr() {


    }

    DotKernelAttr::DotKernelAttr(const DotKernelAttr &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernelAttr::DotKernelAttr(DotKernelAttr &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernelAttr &DotKernelAttr::operator=(const DotKernelAttr &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernelAttr &DotKernelAttr::operator=(DotKernelAttr &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernelAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 0 + eprosima::fastcdr::Cdr::alignment(current_alignment, 0);

            current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernelAttr::getCdrSerializedSize(const DotKernelAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto& a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernelAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernelAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernelAttr::ds(const std::map<PairInt, Attrib> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernelAttr::ds(std::map<PairInt, Attrib> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, Attrib> &DotKernelAttr::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, Attrib> &DotKernelAttr::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernelAttr::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernelAttr::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernelAttr::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernelAttr::cbase() {
        return m_cbase;
    }

    size_t DotKernelAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernelAttr::isKeyDefined() {
        return false;
    }

    void DotKernelAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregEdgeAttr::MvregEdgeAttr() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7bb58ca3
        m_id = 0;
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@c540f5a
        m_from = 0;
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@770c2e6b
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@1a052a00
        m_type = "";
        // m_attr_name com.eprosima.idl.parser.typecode.StringTypeCode@4d826d77
        m_attr_name = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@448ff1a8

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1a38c59b
        m_agent_id = 0;

    }

    MvregEdgeAttr::~MvregEdgeAttr() {


    }

    MvregEdgeAttr::MvregEdgeAttr(const MvregEdgeAttr &x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregEdgeAttr::MvregEdgeAttr(MvregEdgeAttr &&x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregEdgeAttr &MvregEdgeAttr::operator=(const MvregEdgeAttr &x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    MvregEdgeAttr &MvregEdgeAttr::operator=(MvregEdgeAttr &&x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }


    void MvregEdgeAttr::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

    uint64_t MvregEdgeAttr::timestamp() {
        return m_timestamp;
    }

    size_t MvregEdgeAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelAttr::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        return current_alignment - initial_alignment;
    }

    size_t MvregEdgeAttr::getCdrSerializedSize(const MvregEdgeAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.attr_name().size() + 1;

        current_alignment += DotKernelAttr::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    void MvregEdgeAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_from;
        scdr << m_to;
        scdr << m_type;
        scdr << m_attr_name;
        scdr << m_dk;
        scdr << m_agent_id;
        scdr << m_timestamp;
    }

    void MvregEdgeAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_from;
        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_attr_name;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
        dcdr >> m_timestamp;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregEdgeAttr::id(uint64_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint64_t MvregEdgeAttr::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint64_t &MvregEdgeAttr::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void MvregEdgeAttr::from(uint64_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint64_t MvregEdgeAttr::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint64_t &MvregEdgeAttr::from() {
        return m_from;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void MvregEdgeAttr::to(uint64_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint64_t MvregEdgeAttr::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint64_t &MvregEdgeAttr::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void MvregEdgeAttr::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void MvregEdgeAttr::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &MvregEdgeAttr::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &MvregEdgeAttr::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
    void MvregEdgeAttr::attr_name(const std::string &_attr_name) {
        m_attr_name = _attr_name;
    }

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
    void MvregEdgeAttr::attr_name(std::string &&_attr_name) {
        m_attr_name = std::move(_attr_name);
    }

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
    const std::string &MvregEdgeAttr::attr_name() const {
        return m_attr_name;
    }

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
    std::string &MvregEdgeAttr::attr_name() {
        return m_attr_name;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregEdgeAttr::dk(const DotKernelAttr &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregEdgeAttr::dk(DotKernelAttr &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelAttr &MvregEdgeAttr::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelAttr &MvregEdgeAttr::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregEdgeAttr::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregEdgeAttr::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregEdgeAttr::agent_id() {
        return m_agent_id;
    }


    size_t MvregEdgeAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregEdgeAttr::isKeyDefined() {
        return false;
    }

    void MvregEdgeAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    IDLEdge::IDLEdge() {
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@15bb6bea
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@8b96fde
        m_type = "";
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2d2e5f00
        m_from = 0;
        // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@41ee392b

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1e67a849
        m_agent_id = 0;

    }

    IDLEdge::~IDLEdge() {


    }

    IDLEdge::IDLEdge(const IDLEdge &x) {
        m_to = x.m_to;
        m_type = x.m_type;
        m_from = x.m_from;
        m_attrs = x.m_attrs;
        m_agent_id = x.m_agent_id;
    }

    IDLEdge::IDLEdge(IDLEdge &&x) {
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_from = x.m_from;
        m_attrs = std::move(x.m_attrs);
        m_agent_id = x.m_agent_id;
    }

    IDLEdge &IDLEdge::operator=(const IDLEdge &x) {

        m_to = x.m_to;
        m_type = x.m_type;
        m_from = x.m_from;
        m_attrs = x.m_attrs;
        m_agent_id = x.m_agent_id;

        return *this;
    }

    IDLEdge &IDLEdge::operator=(IDLEdge &&x) {

        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_from = x.m_from;
        m_attrs = std::move(x.m_attrs);
        m_agent_id = x.m_agent_id;

        return *this;
    }

    size_t IDLEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 255 + eprosima::fastcdr::Cdr::alignment(current_alignment, 255);

            current_alignment += MvregEdgeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t IDLEdge::getCdrSerializedSize(const IDLEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto &a : data.attrs()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
            current_alignment += MvregEdgeAttr::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void IDLEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_to;
        scdr << m_type;
        scdr << m_from;
        scdr << m_attrs;
        scdr << m_agent_id;
    }

    void IDLEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_from;
        dcdr >> m_attrs;
        dcdr >> m_agent_id;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void IDLEdge::to(uint64_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint64_t IDLEdge::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint64_t &IDLEdge::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void IDLEdge::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void IDLEdge::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &IDLEdge::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &IDLEdge::type() {
        return m_type;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void IDLEdge::from(uint64_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint64_t IDLEdge::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint64_t &IDLEdge::from() {
        return m_from;
    }

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
    void IDLEdge::attrs(const std::map<std::string, MvregEdgeAttr> &_attrs) {
        m_attrs = _attrs;
    }

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
    void IDLEdge::attrs(std::map<std::string, MvregEdgeAttr> &&_attrs) {
        m_attrs = std::move(_attrs);
    }

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
    const std::map<std::string, MvregEdgeAttr> &IDLEdge::attrs() const {
        return m_attrs;
    }

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
    std::map<std::string, MvregEdgeAttr> &IDLEdge::attrs() {
        return m_attrs;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void IDLEdge::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t IDLEdge::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &IDLEdge::agent_id() {
        return m_agent_id;
    }


    size_t IDLEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool IDLEdge::isKeyDefined() {
        return false;
    }

    void IDLEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    EdgeKey::EdgeKey() {
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6ee12bac
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@55040f2f
        m_type = "";

    }

    EdgeKey::~EdgeKey() {


    }

    EdgeKey::EdgeKey(const EdgeKey &x) {
        m_to = x.m_to;
        m_type = x.m_type;
    }

    EdgeKey::EdgeKey(EdgeKey &&x) {
        m_to = x.m_to;
        m_type = std::move(x.m_type);
    }

    EdgeKey &EdgeKey::operator=(const EdgeKey &x) {

        m_to = x.m_to;
        m_type = x.m_type;

        return *this;
    }

    EdgeKey &EdgeKey::operator=(EdgeKey &&x) {

        m_to = x.m_to;
        m_type = std::move(x.m_type);

        return *this;
    }

    size_t EdgeKey::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        return current_alignment - initial_alignment;
    }

    size_t EdgeKey::getCdrSerializedSize(const EdgeKey &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;


        return current_alignment - initial_alignment;
    }

    void EdgeKey::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_to;
        scdr << m_type;
    }

    void EdgeKey::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_to;
        dcdr >> m_type;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void EdgeKey::to(uint64_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint64_t EdgeKey::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint64_t &EdgeKey::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void EdgeKey::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void EdgeKey::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &EdgeKey::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &EdgeKey::type() {
        return m_type;
    }

    size_t EdgeKey::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool EdgeKey::isKeyDefined() {
        return false;
    }

    void EdgeKey::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregNodeAttr::MvregNodeAttr() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@75f9eccc
        m_id = 0;
        // m_node com.eprosima.idl.parser.typecode.PrimitiveTypeCode@52aa2946
        m_node = 0;
        // m_attr_name com.eprosima.idl.parser.typecode.StringTypeCode@4de5031f
        m_attr_name = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@448ff1a8

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5ea434c8
        m_agent_id = 0;

    }

    MvregNodeAttr::~MvregNodeAttr() {


    }

    MvregNodeAttr::MvregNodeAttr(const MvregNodeAttr &x) {
        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregNodeAttr::MvregNodeAttr(MvregNodeAttr &&x) {
        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregNodeAttr &MvregNodeAttr::operator=(const MvregNodeAttr &x) {

        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = x.m_attr_name;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    MvregNodeAttr &MvregNodeAttr::operator=(MvregNodeAttr &&x) {

        m_id = x.m_id;
        m_node = x.m_node;
        m_attr_name = std::move(x.m_attr_name);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

        /*!
     * @brief This function sets a value in member timestamp
     * @param _timestamp New value for member timestamp
     */
    void MvregNodeAttr::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

    /*!
     * @brief This function returns the value of member timestamp
     * @return Value of member timestamp
     */
    uint64_t MvregNodeAttr::timestamp()  {
        return m_timestamp;
    }


    size_t MvregNodeAttr::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelAttr::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    size_t MvregNodeAttr::getCdrSerializedSize(const MvregNodeAttr &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.attr_name().size() + 1;

        current_alignment += DotKernelAttr::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    void MvregNodeAttr::serialize(eprosima::fastcdr::Cdr &scdr) const {

        assert(m_dk.ds().size() <= 1);

        scdr << m_id;
        scdr << m_node;
        scdr << m_attr_name;
        scdr << m_dk;
        scdr << m_agent_id;
        scdr << m_timestamp;
    }

    void MvregNodeAttr::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_node;
        dcdr >> m_attr_name;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
        dcdr >> m_timestamp;

        assert(m_dk.ds().size() <= 1);

    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregNodeAttr::id(uint64_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint64_t MvregNodeAttr::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint64_t &MvregNodeAttr::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member node
 * @param _node New value for member node
 */
    void MvregNodeAttr::node(uint64_t _node) {
        m_node = _node;
    }

/*!
 * @brief This function returns the value of member node
 * @return Value of member node
 */
    uint64_t MvregNodeAttr::node() const {
        return m_node;
    }

/*!
 * @brief This function returns a reference to member node
 * @return Reference to member node
 */
    uint64_t &MvregNodeAttr::node() {
        return m_node;
    }

/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
    void MvregNodeAttr::attr_name(const std::string &_attr_name) {
        m_attr_name = _attr_name;
    }

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
    void MvregNodeAttr::attr_name(std::string &&_attr_name) {
        m_attr_name = std::move(_attr_name);
    }

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
    const std::string &MvregNodeAttr::attr_name() const {
        return m_attr_name;
    }

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
    std::string &MvregNodeAttr::attr_name() {
        return m_attr_name;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregNodeAttr::dk(const DotKernelAttr &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregNodeAttr::dk(DotKernelAttr &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelAttr &MvregNodeAttr::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelAttr &MvregNodeAttr::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregNodeAttr::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregNodeAttr::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregNodeAttr::agent_id() {
        return m_agent_id;
    }


    size_t MvregNodeAttr::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregNodeAttr::isKeyDefined() {
        return false;
    }

    void MvregNodeAttr::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotKernelEdge::DotKernelEdge() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@3bbc39f8

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@51931956


    }

    DotKernelEdge::~DotKernelEdge() {


    }

    DotKernelEdge::DotKernelEdge(const DotKernelEdge &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernelEdge::DotKernelEdge(DotKernelEdge &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernelEdge &DotKernelEdge::operator=(const DotKernelEdge &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernelEdge &DotKernelEdge::operator=(DotKernelEdge &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernelEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 0 + eprosima::fastcdr::Cdr::alignment(current_alignment, 0);

            current_alignment += IDLEdge::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernelEdge::getCdrSerializedSize(const DotKernelEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto &a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += IDLEdge::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernelEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernelEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernelEdge::ds(const std::map<PairInt, IDLEdge> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernelEdge::ds(std::map<PairInt, IDLEdge> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, IDLEdge> &DotKernelEdge::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, IDLEdge> &DotKernelEdge::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernelEdge::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernelEdge::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernelEdge::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernelEdge::cbase() {
        return m_cbase;
    }

    size_t DotKernelEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernelEdge::isKeyDefined() {
        return false;
    }

    void DotKernelEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregEdge::MvregEdge() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4ae3c1cd
        m_id = 0;
        // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@29f69090
        m_from = 0;
        // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@568bf312
        m_to = 0;
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@ca263c2
        m_type = "";
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@589b3632

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@45f45fa1
        m_agent_id = 0;

    }

    MvregEdge::~MvregEdge() {


    }

    MvregEdge::MvregEdge(const MvregEdge &x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregEdge::MvregEdge(MvregEdge &&x) {
        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

    }

    MvregEdge &MvregEdge::operator=(const MvregEdge &x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = x.m_type;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    MvregEdge &MvregEdge::operator=(MvregEdge &&x) {

        m_id = x.m_id;
        m_from = x.m_from;
        m_to = x.m_to;
        m_type = std::move(x.m_type);
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    void MvregEdge::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

    uint64_t MvregEdge::timestamp()  {
        return m_timestamp;
    }

    size_t MvregEdge::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += DotKernelEdge::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    size_t MvregEdge::getCdrSerializedSize(const MvregEdge &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += DotKernelEdge::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    void MvregEdge::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_from;
        scdr << m_to;
        scdr << m_type;
        scdr << m_dk;
        scdr << m_agent_id;
        scdr << m_timestamp;
    }

    void MvregEdge::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_from;
        dcdr >> m_to;
        dcdr >> m_type;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
        dcdr >> m_timestamp;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregEdge::id(uint64_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint64_t MvregEdge::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint64_t &MvregEdge::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
    void MvregEdge::from(uint64_t _from) {
        m_from = _from;
    }

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
    uint64_t MvregEdge::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    uint64_t &MvregEdge::from() {
        return m_from;
    }

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
    void MvregEdge::to(uint64_t _to) {
        m_to = _to;
    }

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
    uint64_t MvregEdge::to() const {
        return m_to;
    }

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
    uint64_t &MvregEdge::to() {
        return m_to;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void MvregEdge::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void MvregEdge::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &MvregEdge::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &MvregEdge::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregEdge::dk(const DotKernelEdge &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregEdge::dk(DotKernelEdge &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernelEdge &MvregEdge::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernelEdge &MvregEdge::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregEdge::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregEdge::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregEdge::agent_id() {
        return m_agent_id;
    }


    size_t MvregEdge::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregEdge::isKeyDefined() {
        return false;
    }

    void MvregEdge::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    IDLNode::IDLNode() {
        // m_type com.eprosima.idl.parser.typecode.StringTypeCode@4c6e276e
        m_type = "";
        // m_name com.eprosima.idl.parser.typecode.StringTypeCode@534df152
        m_name = "";
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@52e677af
        m_id = 0;
        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@35083305
        m_agent_id = 0;
        // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@8e0379d

        // m_fano com.eprosima.idl.parser.typecode.MapTypeCode@341b80b2


    }

    IDLNode::~IDLNode() {


    }

    IDLNode::IDLNode(const IDLNode &x) {
        m_type = x.m_type;
        m_name = x.m_name;
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = x.m_attrs;
        m_fano = x.m_fano;
    }

    IDLNode::IDLNode(IDLNode &&x) {
        m_type = std::move(x.m_type);
        m_name = std::move(x.m_name);
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = std::move(x.m_attrs);
        m_fano = std::move(x.m_fano);
    }

    IDLNode &IDLNode::operator=(const IDLNode &x) {

        m_type = x.m_type;
        m_name = x.m_name;
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = x.m_attrs;
        m_fano = x.m_fano;

        return *this;
    }

    IDLNode &IDLNode::operator=(IDLNode &&x) {

        m_type = std::move(x.m_type);
        m_name = std::move(x.m_name);
        m_id = x.m_id;
        m_agent_id = x.m_agent_id;
        m_attrs = std::move(x.m_attrs);
        m_fano = std::move(x.m_fano);

        return *this;
    }

    size_t IDLNode::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 255 + eprosima::fastcdr::Cdr::alignment(current_alignment, 255);

            current_alignment += MvregNodeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 0 + eprosima::fastcdr::Cdr::alignment(current_alignment, 0);

            current_alignment += MvregEdge::getMaxCdrSerializedSize(current_alignment);
        }


        return current_alignment - initial_alignment;
    }

    size_t IDLNode::getCdrSerializedSize(const IDLNode &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto &a : data.attrs()) {
            (void) a;
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
            current_alignment += MvregNodeAttr::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto& a : data.fano()) {
            (void) a;
            current_alignment += EdgeKey::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += MvregEdge::getCdrSerializedSize((a.second), current_alignment);

        }


        return current_alignment - initial_alignment;
    }

    void IDLNode::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_type;
        scdr << m_name;
        scdr << m_id;
        scdr << m_agent_id;
        scdr << m_attrs;
        scdr << m_fano;
    }

    void IDLNode::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_type;
        dcdr >> m_name;
        dcdr >> m_id;
        dcdr >> m_agent_id;
        dcdr >> m_attrs;
        dcdr >> m_fano;
    }

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
    void IDLNode::type(const std::string &_type) {
        m_type = _type;
    }

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
    void IDLNode::type(std::string &&_type) {
        m_type = std::move(_type);
    }

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
    const std::string &IDLNode::type() const {
        return m_type;
    }

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
    std::string &IDLNode::type() {
        return m_type;
    }

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
    void IDLNode::name(const std::string &_name) {
        m_name = _name;
    }

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
    void IDLNode::name(std::string &&_name) {
        m_name = std::move(_name);
    }

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
    const std::string &IDLNode::name() const {
        return m_name;
    }

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
    std::string &IDLNode::name() {
        return m_name;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void IDLNode::id(uint64_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint64_t IDLNode::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint64_t &IDLNode::id() {
        return m_id;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void IDLNode::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t IDLNode::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &IDLNode::agent_id() {
        return m_agent_id;
    }

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
    void IDLNode::attrs(const std::map<std::string, MvregNodeAttr> &_attrs) {
        m_attrs = _attrs;
    }

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
    void IDLNode::attrs(std::map<std::string, MvregNodeAttr> &&_attrs) {
        m_attrs = std::move(_attrs);
    }

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
    const std::map<std::string, MvregNodeAttr> &IDLNode::attrs() const {
        return m_attrs;
    }

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
    std::map<std::string, MvregNodeAttr> &IDLNode::attrs() {
        return m_attrs;
    }

/*!
 * @brief This function copies the value in member fano
 * @param _fano New value to be copied in member fano
 */
    void IDLNode::fano(const std::map<EdgeKey, MvregEdge> &_fano) {
        m_fano = _fano;
    }

/*!
 * @brief This function moves the value in member fano
 * @param _fano New value to be moved in member fano
 */
    void IDLNode::fano(std::map<EdgeKey, MvregEdge> &&_fano) {
        m_fano = std::move(_fano);
    }

/*!
 * @brief This function returns a constant reference to member fano
 * @return Constant reference to member fano
 */
    const std::map<EdgeKey, MvregEdge> &IDLNode::fano() const {
        return m_fano;
    }

/*!
 * @brief This function returns a reference to member fano
 * @return Reference to member fano
 */
    std::map<EdgeKey, MvregEdge> &IDLNode::fano() {
        return m_fano;
    }

    size_t IDLNode::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool IDLNode::isKeyDefined() {
        return false;
    }

    void IDLNode::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    GraphRequest::GraphRequest() {
        // m_from com.eprosima.idl.parser.typecode.StringTypeCode@1b083826
        m_from = "";
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@105fece7
        m_id = 0;

    }

    GraphRequest::~GraphRequest() {


    }

    GraphRequest::GraphRequest(const GraphRequest &x) {
        m_from = x.m_from;
        m_id = x.m_id;
    }

    GraphRequest::GraphRequest(GraphRequest &&x) {
        m_from = std::move(x.m_from);
        m_id = x.m_id;
    }

    GraphRequest &GraphRequest::operator=(const GraphRequest &x) {

        m_from = x.m_from;
        m_id = x.m_id;

        return *this;
    }

    GraphRequest &GraphRequest::operator=(GraphRequest &&x) {

        m_from = std::move(x.m_from);
        m_id = x.m_id;

        return *this;
    }

    size_t GraphRequest::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    size_t GraphRequest::getCdrSerializedSize(const GraphRequest &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.from().size() + 1;

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        return current_alignment - initial_alignment;
    }

    void GraphRequest::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_from;
        scdr << m_id;
    }

    void GraphRequest::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_from;
        dcdr >> m_id;
    }

/*!
 * @brief This function copies the value in member from
 * @param _from New value to be copied in member from
 */
    void GraphRequest::from(const std::string &_from) {
        m_from = _from;
    }

/*!
 * @brief This function moves the value in member from
 * @param _from New value to be moved in member from
 */
    void GraphRequest::from(std::string &&_from) {
        m_from = std::move(_from);
    }

/*!
 * @brief This function returns a constant reference to member from
 * @return Constant reference to member from
 */
    const std::string &GraphRequest::from() const {
        return m_from;
    }

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
    std::string &GraphRequest::from() {
        return m_from;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void GraphRequest::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t GraphRequest::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &GraphRequest::id() {
        return m_id;
    }


    size_t GraphRequest::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool GraphRequest::isKeyDefined() {
        return false;
    }

    void GraphRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    DotKernel::DotKernel() {
        // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@3ec300f1

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@51931956


    }

    DotKernel::~DotKernel() {


    }

    DotKernel::DotKernel(const DotKernel &x) {
        m_ds = x.m_ds;
        m_cbase = x.m_cbase;
    }

    DotKernel::DotKernel(DotKernel &&x) {
        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);
    }

    DotKernel &DotKernel::operator=(const DotKernel &x) {

        m_ds = x.m_ds;
        m_cbase = x.m_cbase;

        return *this;
    }

    DotKernel &DotKernel::operator=(DotKernel &&x) {

        m_ds = std::move(x.m_ds);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t DotKernel::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 0 + eprosima::fastcdr::Cdr::alignment(current_alignment, 0);

            current_alignment += IDLNode::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t DotKernel::getCdrSerializedSize(const DotKernel &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto& a : data.ds()) {
            (void) a;
            current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
            current_alignment += IDLNode::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void DotKernel::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_ds;
        scdr << m_cbase;
    }

    void DotKernel::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_ds;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
    void DotKernel::ds(const std::map<PairInt, IDLNode> &_ds) {
        m_ds = _ds;
    }

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
    void DotKernel::ds(std::map<PairInt, IDLNode> &&_ds) {
        m_ds = std::move(_ds);
    }

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
    const std::map<PairInt, IDLNode> &DotKernel::ds() const {
        return m_ds;
    }

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
    std::map<PairInt, IDLNode> &DotKernel::ds() {
        return m_ds;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void DotKernel::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void DotKernel::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &DotKernel::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &DotKernel::cbase() {
        return m_cbase;
    }

    size_t DotKernel::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool DotKernel::isKeyDefined() {
        return false;
    }

    void DotKernel::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregNode::MvregNode() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@482cd91f
        m_id = 0;
        // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@123f1134

        // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7d68ef40
        m_agent_id = 0;

    }

    MvregNode::~MvregNode() {


    }

    MvregNode::MvregNode(const MvregNode &x) {
        m_id = x.m_id;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;
    }

    MvregNode::MvregNode(MvregNode &&x) {
        m_id = x.m_id;
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;
    }

    MvregNode &MvregNode::operator=(const MvregNode &x) {

        m_id = x.m_id;
        m_dk = x.m_dk;
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    MvregNode &MvregNode::operator=(MvregNode &&x) {

        m_id = x.m_id;
        m_dk = std::move(x.m_dk);
        m_agent_id = x.m_agent_id;
        m_timestamp = x.m_timestamp;

        return *this;
    }

    void MvregNode::timestamp(uint64_t _timestamp) {
        m_timestamp = _timestamp;
    }

    uint64_t MvregNode::timestamp()  {
        return m_timestamp;
    }

    size_t MvregNode::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += DotKernel::getMaxCdrSerializedSize(current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    size_t MvregNode::getCdrSerializedSize(const MvregNode &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


        current_alignment += DotKernel::getCdrSerializedSize(data.dk(), current_alignment);
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        return current_alignment - initial_alignment;
    }

    void MvregNode::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_dk;
        scdr << m_agent_id;
        scdr << m_timestamp;
    }

    void MvregNode::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_dk;
        dcdr >> m_agent_id;
        dcdr >> m_timestamp;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void MvregNode::id(uint64_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint64_t MvregNode::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint64_t &MvregNode::id() {
        return m_id;
    }

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
    void MvregNode::dk(const DotKernel &_dk) {
        m_dk = _dk;
    }

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
    void MvregNode::dk(DotKernel &&_dk) {
        m_dk = std::move(_dk);
    }

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
    const DotKernel &MvregNode::dk() const {
        return m_dk;
    }

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
    DotKernel &MvregNode::dk() {
        return m_dk;
    }

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
    void MvregNode::agent_id(uint32_t _agent_id) {
        m_agent_id = _agent_id;
    }

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
    uint32_t MvregNode::agent_id() const {
        return m_agent_id;
    }

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
    uint32_t &MvregNode::agent_id() {
        return m_agent_id;
    }


    size_t MvregNode::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregNode::isKeyDefined() {
        return false;
    }

    void MvregNode::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    OrMap::OrMap() {
        // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5b0abc94
        m_id = 0;
        // m_m com.eprosima.idl.parser.typecode.MapTypeCode@75c072cb

        // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@51931956


    }

    OrMap::~OrMap() {


    }

    OrMap::OrMap(const OrMap &x) {
        m_id = x.m_id;
        m_to_id = x.m_to_id;
        m_m = x.m_m;
        m_cbase = x.m_cbase;
    }

    OrMap::OrMap(OrMap &&x) {
        m_id = x.m_id;
        m_to_id = x.m_to_id;
        m_m = std::move(x.m_m);
        m_cbase = std::move(x.m_cbase);
    }

    OrMap &OrMap::operator=(const OrMap &x) {

        m_id = x.m_id;
        m_to_id = x.m_to_id;
        m_m = x.m_m;
        m_cbase = x.m_cbase;

        return *this;
    }

    OrMap &OrMap::operator=(OrMap &&x)  {

        m_id = x.m_id;
        m_to_id = x.m_to_id;
        m_m = std::move(x.m_m);
        m_cbase = std::move(x.m_cbase);

        return *this;
    }

    size_t OrMap::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (size_t a = 0; a < 100; ++a) {
            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

            current_alignment += MvregNode::getMaxCdrSerializedSize(current_alignment);
        }

        current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

        return current_alignment - initial_alignment;
    }

    size_t OrMap::getCdrSerializedSize(const OrMap &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        for (const auto& a : data.m()) {
            (void) a;
            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


            current_alignment += MvregNode::getCdrSerializedSize((a.second), current_alignment);

        }


        current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

        return current_alignment - initial_alignment;
    }

    void OrMap::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_id;
        scdr << m_to_id;
        scdr << m_m;
        scdr << m_cbase;
    }

    void OrMap::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_id;
        dcdr >> m_to_id;
        dcdr >> m_m;
        dcdr >> m_cbase;
    }

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void OrMap::id(uint32_t _id) {
        m_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t OrMap::id() const {
        return m_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &OrMap::id() {
        return m_id;
    }

    /*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
    void OrMap::to_id(uint32_t _id) {
        m_to_id = _id;
    }

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
    uint32_t OrMap::to_id() const {
        return m_to_id;
    }

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
    uint32_t &OrMap::to_id() {
        return m_to_id;
    }

    /*!
 * @brief This function copies the value in member m
 * @param _m New value to be copied in member m
 */
    void OrMap::m(const std::map<uint64_t, MvregNode> &_m) {
        m_m = _m;
    }

/*!
 * @brief This function moves the value in member m
 * @param _m New value to be moved in member m
 */
    void OrMap::m(std::map<uint64_t, MvregNode> &&_m) {
        m_m = std::move(_m);
    }

/*!
 * @brief This function returns a constant reference to member m
 * @return Constant reference to member m
 */
    const std::map<uint64_t, MvregNode> &OrMap::m() const {
        return m_m;
    }

/*!
 * @brief This function returns a reference to member m
 * @return Reference to member m
 */
    std::map<uint64_t, MvregNode> &OrMap::m() {
        return m_m;
    }

/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
    void OrMap::cbase(const DotContext &_cbase) {
        m_cbase = _cbase;
    }

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
    void OrMap::cbase(DotContext &&_cbase) {
        m_cbase = std::move(_cbase);
    }

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
    const DotContext &OrMap::cbase() const {
        return m_cbase;
    }

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
    DotContext &OrMap::cbase() {
        return m_cbase;
    }

    size_t OrMap::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool OrMap::isKeyDefined() {
        return false;
    }

    void OrMap::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;


    }

    MvregEdgeAttrVec::MvregEdgeAttrVec() {
        // m_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@214b199c


    }

    MvregEdgeAttrVec::~MvregEdgeAttrVec() {
    }

    MvregEdgeAttrVec::MvregEdgeAttrVec(const MvregEdgeAttrVec &x) {
        m_vec = x.m_vec;
    }

    MvregEdgeAttrVec::MvregEdgeAttrVec(MvregEdgeAttrVec &&x) {
        m_vec = std::move(x.m_vec);
    }

    MvregEdgeAttrVec &MvregEdgeAttrVec::operator=(const MvregEdgeAttrVec &x) {

        m_vec = x.m_vec;

        return *this;
    }

    MvregEdgeAttrVec &MvregEdgeAttrVec::operator=(MvregEdgeAttrVec &&x) {

        m_vec = std::move(x.m_vec);

        return *this;
    }

    size_t MvregEdgeAttrVec::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < 100; ++a) {
            current_alignment += MvregEdgeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        return current_alignment - initial_alignment;
    }

    size_t MvregEdgeAttrVec::getCdrSerializedSize(const MvregEdgeAttrVec &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < data.vec().size(); ++a) {
            current_alignment += MvregEdgeAttr::getCdrSerializedSize(data.vec().at(a), current_alignment);
        }

        return current_alignment - initial_alignment;
    }

    void MvregEdgeAttrVec::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_vec;
    }

    void MvregEdgeAttrVec::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_vec;
    }

/*!
 * @brief This function copies the value in member vec
 * @param _vec New value to be copied in member vec
 */
    void MvregEdgeAttrVec::vec(const std::vector<MvregEdgeAttr> &_vec) {
        m_vec = _vec;
    }

/*!
 * @brief This function moves the value in member vec
 * @param _vec New value to be moved in member vec
 */
    void MvregEdgeAttrVec::vec(std::vector<MvregEdgeAttr> &&_vec) {
        m_vec = std::move(_vec);
    }

/*!
 * @brief This function returns a constant reference to member vec
 * @return Constant reference to member vec
 */
    const std::vector<MvregEdgeAttr> &MvregEdgeAttrVec::vec() const {
        return m_vec;
    }

/*!
 * @brief This function returns a reference to member vec
 * @return Reference to member vec
 */
    std::vector<MvregEdgeAttr> &MvregEdgeAttrVec::vec() {
        return m_vec;
    }

    size_t MvregEdgeAttrVec::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregEdgeAttrVec::isKeyDefined() {
        return false;
    }

    void MvregEdgeAttrVec::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;

    }

    MvregNodeAttrVec::MvregNodeAttrVec() {
        // m_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@25a65b77


    }

    MvregNodeAttrVec::~MvregNodeAttrVec() {
    }

    MvregNodeAttrVec::MvregNodeAttrVec(const MvregNodeAttrVec &x) {
        m_vec = x.m_vec;
    }

    MvregNodeAttrVec::MvregNodeAttrVec(MvregNodeAttrVec &&x) {
        m_vec = std::move(x.m_vec);
    }

    MvregNodeAttrVec &MvregNodeAttrVec::operator=(const MvregNodeAttrVec &x) {

        m_vec = x.m_vec;

        return *this;
    }

    MvregNodeAttrVec &MvregNodeAttrVec::operator=(MvregNodeAttrVec &&x) {

        m_vec = std::move(x.m_vec);

        return *this;
    }

    size_t MvregNodeAttrVec::getMaxCdrSerializedSize(size_t current_alignment) {
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < 100; ++a) {
            current_alignment += MvregNodeAttr::getMaxCdrSerializedSize(current_alignment);
        }

        return current_alignment - initial_alignment;
    }

    size_t MvregNodeAttrVec::getCdrSerializedSize(const MvregNodeAttrVec &data, size_t current_alignment) {
        (void) data;
        size_t initial_alignment = current_alignment;


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        for (size_t a = 0; a < data.vec().size(); ++a) {
            current_alignment += MvregNodeAttr::getCdrSerializedSize(data.vec().at(a), current_alignment);
        }

        return current_alignment - initial_alignment;
    }

    void MvregNodeAttrVec::serialize(eprosima::fastcdr::Cdr &scdr) const {

        scdr << m_vec;
    }

    void MvregNodeAttrVec::deserialize(eprosima::fastcdr::Cdr &dcdr) {

        dcdr >> m_vec;
    }

/*!
 * @brief This function copies the value in member vec
 * @param _vec New value to be copied in member vec
 */
    void MvregNodeAttrVec::vec(const std::vector<MvregNodeAttr> &_vec) {
        m_vec = _vec;
    }

/*!
 * @brief This function moves the value in member vec
 * @param _vec New value to be moved in member vec
 */
    void MvregNodeAttrVec::vec(std::vector<MvregNodeAttr> &&_vec) {
        m_vec = std::move(_vec);
    }

/*!
 * @brief This function returns a constant reference to member vec
 * @return Constant reference to member vec
 */
    const std::vector<MvregNodeAttr> &MvregNodeAttrVec::vec() const {
        return m_vec;
    }

/*!
 * @brief This function returns a reference to member vec
 * @return Reference to member vec
 */
    std::vector<MvregNodeAttr> &MvregNodeAttrVec::vec() {
        return m_vec;
    }

    size_t MvregNodeAttrVec::getKeyMaxCdrSerializedSize(size_t current_alignment) {
        size_t current_align = current_alignment;


        return current_align;
    }

    bool MvregNodeAttrVec::isKeyDefined() {
        return false;
    }

    void MvregNodeAttrVec::serializeKey(eprosima::fastcdr::Cdr &scdr) const {
        (void) scdr;

    }

}